<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bus Burgos | Mapa y Buscador en Vivo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Incluir Leaflet Polyline Snake Flow para el efecto visual de la ruta -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polyline-snake-flow/0.0.1/L.Polyline.SnakeFlow.min.js"></script>

    <style>
        /* Estilo base del mapa */
        #map {
            height: 70vh;
            min-height: 400px;
            width: 100%;
            border-radius: 0.75rem; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* Estilo para los marcadores de bus */
        .bus-icon {
            background-color: #2563EB; /* Azul primario */
            border: 3px solid #1E40AF;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            text-align: center;
            line-height: 30px;
            color: white;
            font-weight: bold;
            font-size: 15px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease-out;
            transform: scale(0.9);
        }
        .bus-icon:hover {
             transform: scale(1.1);
        }
        /* Estilo para los marcadores de parada (Ajustado para mejor control con Leaflet) */
        .stop-icon {
            background-color: white;
            border: 2px solid #1E40AF; /* Borde azul */
            border-radius: 50%;
            /* Definimos el tama√±o exacto en el CSS */
            width: 16px; 
            height: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        /* Estilo para la m√°scara de carga (Spinner de Tailwind) */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 0.75rem;
            transition: opacity 0.3s ease;
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 sm:p-8 font-sans">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 border-b-2 border-blue-500 pb-2">üöç Bus Burgos en Tiempo Real</h1>
            <p class="text-gray-600 mt-2">Localizaci√≥n de veh√≠culos y horarios de parada en toda la red.</p>
        </header>

        <div class="bg-white p-6 rounded-xl shadow-2xl mb-8">
            <div class="mb-6 border-b pb-4">
                <label for="bus-search" class="block text-sm font-bold text-gray-700 mb-2">üîé Buscar Autob√∫s por ID:</label>
                <div class="flex gap-3">
                    <input type="text" id="bus-search" placeholder="Ej: 152" class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                    <button id="search-button" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out">Buscar</button>
                </div>
            </div>

            <div class="flex flex-col sm:flex-row gap-4 sm:gap-6 items-center">
                <div class="w-full sm:w-1/2">
                    <label for="line-select" class="block text-sm font-medium text-gray-700 mb-1">Seleccionar L√≠nea:</label>
                    <select id="line-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm bg-gray-50">
                        <option value="">Cargando l√≠neas...</option>
                    </select>
                </div>

                <div class="w-full sm:w-1/2">
                    <label for="route-variant-select" class="block text-sm font-medium text-gray-700 mb-1">Seleccionar Sentido:</label>
                    <select id="route-variant-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm bg-gray-50" disabled>
                        <option value="">Seleccione una l√≠nea primero</option>
                    </select>
                </div>
            </div>

            <div id="status-message" class="mt-4 text-sm font-medium p-3 rounded-lg hidden text-center"></div>
        </div>

        <div class="relative">
            <div id="map"></div>
            <div id="loading-overlay" class="loading-overlay hidden">
                <svg class="animate-spin h-10 w-10 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p class="mt-4 text-lg font-semibold text-gray-700">Iniciando monitor en tiempo real...</p>
            </div>
        </div>
    </div>

    <script>
        // === ADVERTENCIA CR√çTICA: PROBLEMA DE CORS ===
        // El funcionamiento de esta aplicaci√≥n depende al 100% de que el servicio de proxy
        // externo (corsproxy.io) est√© activo y pueda reenviar las peticiones a la API del
        // Ayuntamiento de Burgos. Si el proxy falla, la aplicaci√≥n dejar√° de mostrar datos.
        // === FIN ADVERTENCIA ===

        // --- Configuraci√≥n Global ---
        const BASE_URL = 'https://www.aytoburgos.es/web/movilidad/rutas-en-directo';
        const CORS_PROXY = 'https://corsproxy.io/?'; // Proxy para evitar errores CORS
        // Reducimos el polling de la l√≠nea seleccionada para una mejor experiencia
        const POLLING_LINE_MS = 15000; 
        // Polling m√°s lento para el monitor global del buscador
        const POLLING_GLOBAL_MS = 45000; 
        const PORTLET_PREFIX = '_as_asac_isaenext_IsaenextWebPortlet_';
        const BASE_PARAMS = 'p_p_id=as_asac_isaenext_IsaenextWebPortlet&p_p_lifecycle=2&p_p_state=normal&p_p_mode=view&p_p_cacheability=cacheLevelPage';

        const ALL_LINES = [
            '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17',
            '18', '19', '20', '21', '22', '23', '73', '87', '88', '89', 'C1', 'C2'
        ];
        
        // --- REQUISITO: Datos Est√°ticos de la Flota ---
        const BUS_FLEET_DATA = {
            '134': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '126585 DVG', calca: '134' },
            '135': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '123566 DVG', calca: '135' },
            '137': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '127791 FJF', calca: '137' },
            '138': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '128054 FJF', calca: '138' },
            '139': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '128168 FJF', calca: '139' },
            '167': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '127933 JVR', calca: '167' },
            '168': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '128060 JVR', calca: '168' },
            '169': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '128117 JVR', calca: '169' },
            '179': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '127327 JZP', calca: '179' },
            '180': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '127360 JZP', calca: '180' },
            '181': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '127463 JZP', calca: '181' },
            '183': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '127394 JZP', calca: '183' },
            '184': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '129941 KPK', calca: '184' },
            '185': { modelo: 'Castrosua CS.40 City Versus GNC', matricula: '129992 KPK', calca: '185' },
            '187': { modelo: 'Castrosua New City GNC', matricula: '124690 KXD', calca: '187' },
            '188': { modelo: 'Castrosua New City GNC', matricula: '124852 KXD', calca: '188' },
            '227': { modelo: 'Castrosua New City GNC', matricula: '184644 KXD', calca: '227' },
            '170': { modelo: 'Integralia In-Urban', matricula: '3516 JVK', calca: '170' },
            '189': { modelo: 'Integralia In-Urban', matricula: '8273 LDM', calca: '189' },
            '171': { modelo: 'Integralia Tatoo', matricula: '3602 JVK', calca: '171' },
            '190': { modelo: 'Integralia Tatoo', matricula: '8430 LDM', calca: '190' },
            '157': { modelo: 'Mercedes-Benz Citaro C2', matricula: '8536 JDV', calca: '157' },
            '158': { modelo: 'Mercedes-Benz Citaro C2', matricula: '8572 JDV', calca: '158' },
            '159': { modelo: 'Mercedes-Benz Citaro C2', matricula: '8606 JDV', calca: '159' },
            '160': { modelo: 'Mercedes-Benz Citaro C2', matricula: '8628 JDV', calca: '160' },
            '161': { modelo: 'Mercedes-Benz Citaro C2', matricula: '8639 JDV', calca: '161' },
            '162': { modelo: 'Mercedes-Benz Citaro C2', matricula: '8656 JDV', calca: '162' },
            '163': { modelo: 'Mercedes-Benz Citaro C2', matricula: '8725 JDV', calca: '163' },
            '164': { modelo: 'Mercedes-Benz Citaro C2', matricula: '8766 JDV', calca: '164' },
            '165': { modelo: 'Mercedes-Benz Citaro C2', matricula: '8781 JDV', calca: '165' },
            '166': { modelo: 'Mercedes-Benz Citaro C2', matricula: '8804 JDV', calca: '166' },
            '173': { modelo: 'Mercedes-Benz Citaro C2', matricula: '3271 JZW', calca: '173' },
            '174': { modelo: 'Mercedes-Benz Citaro C2', matricula: '3395 JZW', calca: '174' },
            '175': { modelo: 'Mercedes-Benz Citaro C2', matricula: '3355 JZW', calca: '175' },
            '176': { modelo: 'Mercedes-Benz Citaro C2', matricula: '3450 JZW', calca: '176' },
            '177': { modelo: 'Mercedes-Benz Citaro C2', matricula: '3483 JZW', calca: '177' },
            '178': { modelo: 'Mercedes-Benz Citaro C2', matricula: '3565 JZW', calca: '178' },
            '212': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '3624 JZW', calca: '212' },
            '213': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '3638 JZW', calca: '213' },
            '214': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '3760 JZW', calca: '214' },
            '215': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '3798 JZW', calca: '215' },
            '216': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '3844 JZW', calca: '216' },
            '217': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '3898 JZW', calca: '217' },
            '218': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '3965 JZW', calca: '218' },
            '219': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '3976 JZW', calca: '219' },
            '220': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '3988 JZW', calca: '220' },
            '221': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '4005 JZW', calca: '221' },
            '222': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '4072 JZW', calca: '222' },
            '223': { modelo: 'Mercedes-Benz Citaro C2 G', matricula: '4104 JZW', calca: '223' },
            '140': { modelo: 'Noge Cittour GNC', matricula: '4057 FTT', calca: '140' },
            '141': { modelo: 'Noge Cittour GNC', matricula: '4197 FTT', calca: '141' },
            '191': { modelo: 'Solaris Urbino IV 12 CNG', matricula: '7507 LJH', calca: '191' },
            '192': { modelo: 'Solaris Urbino IV 12 CNG', matricula: '7266 LJH', calca: '192' },
            '193': { modelo: 'Solaris Urbino IV 12 CNG', matricula: '7432 LJH', calca: '193' },
            '194': { modelo: 'Solaris Urbino IV 12 CNG', matricula: '7552 LJH', calca: '194' },
            '197': { modelo: 'Solaris Urbino IV 12 CNG', matricula: '3371 MBD', calca: '197' },
            '198': { modelo: 'Solaris Urbino IV 12 CNG', matricula: '4551 MKF', calca: '198' },
            '199': { modelo: 'Solaris Urbino IV 12 CNG', matricula: '4568 MKF', calca: '199' },
            '300': { modelo: 'Solaris Urbino IV 12 CNG', matricula: '4590 MKF', calca: '300' },
            '228': { modelo: 'Solaris Urbino IV 18 CNG', matricula: '1046 LJK', calca: '228' },
            '229': { modelo: 'Solaris Urbino IV 18 CNG', matricula: '3449 MBD', calca: '229' },
            '230': { modelo: 'Solaris Urbino IV 18 CNG', matricula: '3486 MBD', calca: '230' },
            '231': { modelo: 'Solaris Urbino IV 18 CNG', matricula: '4602 MKF', calca: '231' },
            '232': { modelo: 'Solaris Urbino IV 18 CNG', matricula: '4622 MKF', calca: '232' },
            '172': { modelo: 'Vectia Veris.12 Hybrid', matricula: '5485 JWH', calca: '172' }
        };

        // --- Variables Globales del Estado y Mapa ---
        let map;
        let busMarkersLayer;
        let routeLineLayer;
        let stopMarkersLayer;
        // Intervalos de Polling
        let globalMonitorInterval; 
        let currentLineMonitorInterval; 

        const allRoutes = {}; // Cach√© de rutas (geometr√≠a y variantes)
        const stopDataCache = {}; // Cach√© de datos de paradas
        const busMarkers = new Map(); // Marcadores de la l√≠nea actual
        const ALL_ACTIVE_BUSES = new Map(); // Cach√© Global para el Buscador

        const lineSelect = document.getElementById('line-select');
        const routeVariantSelect = document.getElementById('route-variant-select');
        const statusMessage = document.getElementById('status-message');
        const loadingOverlay = document.getElementById('loading-overlay');
        const busSearchInput = document.getElementById('bus-search');
        const searchButton = document.getElementById('search-button');

        // --- Funciones de Utilidad y UI ---

        function showLoading(message = "Obteniendo datos en tiempo real...") {
            const loadingText = loadingOverlay.querySelector('p');
            if (loadingText) loadingText.textContent = message;
            loadingOverlay.classList.remove('hidden');
            statusMessage.classList.add('hidden');
        }

        function hideLoading() {
            loadingOverlay.classList.add('hidden');
        }

        function showStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.classList.remove('hidden', 'bg-red-100', 'bg-blue-100', 'text-red-800', 'text-blue-800');

            if (isError) {
                statusMessage.classList.add('bg-red-100', 'text-red-800');
                console.error("ERROR de la aplicaci√≥n:", message);
            } else {
                statusMessage.classList.add('bg-blue-100', 'text-blue-800');
            }
        }

        /**
         * @function secondsToTime
         * @description Convierte segundos a formato "X min" (solo minutos)
         */
        function secondsToTime(seconds) {
            const sec = parseInt(seconds);
            if (isNaN(sec) || sec < 0) return "Desconocido";

            const minutes = Math.floor(sec / 60);
            
            if (minutes === 0) {
                return sec < 30 ? "Inmediato" : "1 min";
            }
            return `${minutes} min`;
        }

        // --- L√≥gica de la API y Fetching (Optimizaci√≥n de reintentos) ---

        async function fetchWithRetry(url, retries = 3, isPolling = false) { // **MODIFICACI√ìN: A√±adir isPolling**
            for (let i = 0; i < retries; i++) {
                try {
                    // **MODIFICACI√ìN: A√±adir encabezados para simular Referer y evitar 403**
                    const headers = new Headers();
                    // Simular que la solicitud proviene de la p√°gina de rutas de Burgos
                    headers.append('Referer', BASE_URL); 

                    const response = await fetch(CORS_PROXY + encodeURIComponent(url), { headers: headers });
                    
                    if (!response.ok) {
                        // Si es un 403 y estamos en modo polling, no lanzar el error de inmediato para reintentar silenciosamente
                        if (isPolling && response.status === 403 && i < retries - 1) {
                             console.warn(`[Polling Silencioso] 403 en reintento ${i + 1}. Reintentando...`);
                        } else {
                            throw new Error(`HTTP error! status: ${response.status} (${response.statusText})`);
                        }
                    } else {
                        const text = await response.text();
                        
                        if (!text || text.toLowerCase().trim() === 'null' || text.toLowerCase().trim() === '[]') {
                             return [];
                        }

                        try {
                            let jsonText = text;
                            if (text.startsWith('URL_DECODED:')) {
                                jsonText = decodeURIComponent(text.replace('URL_DECODED:', ''));
                            }
                            return JSON.parse(jsonText);
                        } catch (e) {
                            throw new Error(`Error al procesar la respuesta del servidor (No es JSON v√°lido).`);
                        }
                    }
                } catch (error) {
                    if (i === retries - 1) {
                        // Lanzar error si es el √∫ltimo reintento
                        throw new Error(`Error final al obtener datos: ${error.message}`);
                    }
                    // Espera exponencial antes de reintentar
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                }
            }
        }

        async function fetchBurgosAPI(resourceId, lineId, extraParams = {}) {
            const dynamicParams = new URLSearchParams();

            dynamicParams.set(PORTLET_PREFIX + 'formDate', Date.now());
            dynamicParams.set(PORTLET_PREFIX + 'tipo', '1');
            dynamicParams.set(PORTLET_PREFIX + 'line', lineId);
            dynamicParams.set(PORTLET_PREFIX + 'label', lineId);

            for (const key in extraParams) {
                dynamicParams.set(PORTLET_PREFIX + key, extraParams[key]);
            }

            const targetUrl = `${BASE_URL}?${BASE_PARAMS}&p_p_resource_id=${resourceId}&${dynamicParams.toString()}`;
            
            // Determinar si es una llamada de Polling (recurrentes y tolerantes a fallos)
            const isPollingCall = resourceId === 'resourceVehicles';

            try {
                return await fetchWithRetry(targetUrl, 3, isPollingCall); // **MODIFICACI√ìN: Pasar isPollingCall**
            } catch (error) {
                // Solo mostrar error de la UI si no es un polling background
                if(!isPollingCall) {
                    showStatus(error.message, true);
                }
                throw error;
            }
        }
        
        // --- Funciones de Inicializaci√≥n ---
        
        function loadAllLines() {
            lineSelect.innerHTML = '<option value="">Seleccione una l√≠nea</option>';

            ALL_LINES.forEach(lineId => {
                const option = document.createElement('option');
                option.value = lineId;
                option.textContent = `L√≠nea ${lineId}`;
                lineSelect.appendChild(option);
            });
            hideLoading();
            showStatus("Seleccione una l√≠nea o use el buscador para empezar.", false);
        }

        function setupEventListeners() {
            lineSelect.onchange = handleLineChange;
            routeVariantSelect.onchange = handleRouteVariantChange;
            searchButton.onclick = searchBusById;
            busSearchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') searchBusById();
            });
        }
        
        function initMap() {
            map = L.map('map').setView([42.3459, -3.6969], 14);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map);

            busMarkersLayer = L.layerGroup().addTo(map);
            routeLineLayer = L.layerGroup().addTo(map);
            stopMarkersLayer = L.layerGroup().addTo(map);

            loadAllLines();
            setupEventListeners();
            
            // Iniciar el monitor global (m√°s lento) para alimentar el buscador
            startGlobalVehicleMonitor();
        }
        
        // --- Buscador Global (Solo cach√©, no dibuja) ---

        function startGlobalVehicleMonitor() {
            if (globalMonitorInterval) {
                clearInterval(globalMonitorInterval);
            }
            
            updateAllVehiclesGlobally();
            globalMonitorInterval = setInterval(updateAllVehiclesGlobally, POLLING_GLOBAL_MS);
            console.log(`Monitor Global de Buses iniciado: Polling cada ${POLLING_GLOBAL_MS / 1000}s`);
        }
        
        async function updateAllVehiclesGlobally() {
            // Carga todas las l√≠neas de forma concurrente para la cach√© global del buscador
            const linePromises = ALL_LINES.map(lineId => 
                fetchBurgosAPI('resourceVehicles', lineId)
                    .then(data => ({ lineId, data }))
                    .catch(() => ({ lineId, data: [] })) // Silenciar errores para no inundar la consola
            );

            const results = await Promise.all(linePromises);
            
            const newActiveBuses = new Map();
            
            results.forEach(result => {
                if (Array.isArray(result.data)) {
                    result.data.forEach(bus => {
                        newActiveBuses.set(bus.id.toString(), {
                            ...bus, 
                            lineId: result.lineId 
                        });
                    });
                }
            });

            // Reemplazar la cach√© global
            ALL_ACTIVE_BUSES.clear();
            newActiveBuses.forEach((bus, id) => ALL_ACTIVE_BUSES.set(id, bus));
        }

        function searchBusById() {
            const busId = busSearchInput.value.trim();
            if (!busId || isNaN(busId)) {
                showStatus("Introduzca un ID de autob√∫s num√©rico v√°lido.", true);
                return;
            }

            const busData = ALL_ACTIVE_BUSES.get(busId);
            
            if (!busData) {
                showStatus(`Autob√∫s ID ${busId} no encontrado o no activo. Intente de nuevo en ${POLLING_GLOBAL_MS / 1000} segundos.`, true);
                return;
            }

            showLoading(`Localizando Bus ID ${busId} en L√≠nea ${busData.lineId}...`);

            // 1. Seleccionar la l√≠nea en los dropdowns
            lineSelect.value = busData.lineId;
            
            // 2. Disparar el cambio de l√≠nea para cargar la ruta y los marcadores
            handleLineChange({ target: lineSelect }).then(() => {
                // Ahora que los marcadores de la l√≠nea est√°n cargados, buscamos el bus y centramos
                const marker = busMarkers.get(busId);
                if (marker) {
                    // **FIX DEL FALLO 2:** Centrar el mapa despu√©s de que la l√≠nea se ha cargado.
                    map.setView([busData.lat, busData.lng], 16);
                    marker.openPopup();
                    hideLoading();
                    showStatus(`Bus ID ${busId} encontrado en L√≠nea ${busData.lineId}.`, false);
                } else {
                    // Esto puede ocurrir si el bus desapareci√≥ entre el polling global y la carga de la l√≠nea
                    hideLoading();
                    showStatus(`Bus ID ${busId} ya no est√° activo en L√≠nea ${busData.lineId}.`, true);
                }
            });
        }

        // --- L√≥gica de Manejo de Filtros y Polling de L√≠nea Activa ---

        function stopLineMonitor() {
            if (currentLineMonitorInterval) {
                clearInterval(currentLineMonitorInterval);
                currentLineMonitorInterval = null;
            }
        }
        
        function startLineMonitor(lineId) {
            stopLineMonitor(); // Asegura que solo haya un monitor activo
            
            // Funci√≥n de polling para actualizar los marcadores de la l√≠nea actual
            const poller = async () => {
                // Obtener datos del veh√≠culo solo de la l√≠nea seleccionada (m√°s r√°pido que la cach√© global)
                try {
                    const vehiclesData = await fetchBurgosAPI('resourceVehicles', lineId);
                    updateBusMarkers(lineId, vehiclesData);
                } catch (e) {
                    // El error 403 est√° siendo manejado silenciosamente en fetchBurgosAPI/fetchWithRetry
                    console.error(`Error en el monitor de la L√≠nea ${lineId} (Error no fatal, intentando de nuevo):`, e.message);
                }
            };
            
            poller(); // Ejecutar inmediatamente
            currentLineMonitorInterval = setInterval(poller, POLLING_LINE_MS);
            console.log(`Monitor de L√≠nea ${lineId} iniciado: Polling cada ${POLLING_LINE_MS / 1000}s`);
        }

        async function handleLineChange(event) {
            const lineId = event.target.value;

            if (!lineId) {
                stopLineMonitor(); // Detener si no hay l√≠nea seleccionada
                clearMapLayers();
                routeVariantSelect.innerHTML = '<option value="">Seleccione una l√≠nea primero</option>';
                routeVariantSelect.disabled = true;
                return;
            }
            
            showLoading(`Cargando rutas para la L√≠nea ${lineId}...`);
            await loadRouteVariants(lineId);
            
            hideLoading();
        }

        async function loadRouteVariants(lineId) {
            try {
                const routeData = await fetchBurgosAPI('resourceRoutes', lineId);
                allRoutes[lineId] = routeData;

                routeVariantSelect.innerHTML = '<option value="">Seleccione un sentido</option>';
                
                if (!routeData || routeData.length === 0) {
                    showStatus(`L√≠nea ${lineId} sin rutas activas o datos no disponibles.`, false);
                    clearMapLayers();
                    stopLineMonitor(); // Detener monitor si no hay rutas
                    routeVariantSelect.disabled = true;
                    return;
                }

                routeData.forEach(variant => {
                    const option = document.createElement('option');
                    option.value = variant.id;
                    option.textContent = variant.label;
                    routeVariantSelect.appendChild(option);
                });
                
                routeVariantSelect.onchange = handleRouteVariantChange;
                routeVariantSelect.disabled = false;
                
                // Cargar la primera variante por defecto
                if (routeData.length > 0) {
                    routeVariantSelect.value = routeData[0].id;
                    await handleRouteVariantChange({ target: routeVariantSelect, isDefault: true });
                }

            } catch (error) {
                showStatus(`Error al cargar variantes de la L√≠nea ${lineId}. Revise la consola.`, true);
                clearMapLayers();
                stopLineMonitor();
            }
        }
        
        async function handleRouteVariantChange(event) {
            const variantId = event.target.value;
            const lineId = lineSelect.value;
            if (!variantId) {
                clearMapLayers();
                stopLineMonitor();
                return;
            }
            
            showLoading("Dibujando ruta y cargando paradas...");
            await renderRouteAndStops(lineId, variantId);
            
            // Iniciar monitor de la l√≠nea activa para refrescar los buses
            startLineMonitor(lineId); 
            
            hideLoading();
            showStatus(`L√≠nea ${lineId} cargada. Sentido: ${event.target.options[event.target.selectedIndex].text}`, false);
        }

        function clearMapLayers() {
            busMarkersLayer.clearLayers();
            routeLineLayer.clearLayers();
            stopMarkersLayer.clearLayers();
            busMarkers.clear();
        }

        async function renderRouteAndStops(lineId, variantId) {
            // No limpiar la capa de buses aqu√≠, ya que el polling puede estar activo
            routeLineLayer.clearLayers();
            stopMarkersLayer.clearLayers();
            
            const variant = allRoutes[lineId].find(v => v.id === variantId);
            if (!variant) return;

            drawRoutePath(variant.latLngs);
            await drawStops(lineId, variant.routeNode);
        }

        function drawRoutePath(latLngs) {
            if (!latLngs || latLngs.length === 0) return;
            const path = latLngs.map(p => [p.lat, p.lng]);
            const polyline = L.polyline(path, { color: '#2563EB', weight: 5, opacity: 0.7 }).addTo(routeLineLayer);
            map.fitBounds(polyline.getBounds());
            
            // Efecto SnakeFlow
            if (L.Polyline.SnakeFlow) {
                 L.polyline(path, { color: '#2563EB', weight: 0, flow: {length: 30, trail: 5, color: '#1E40AF', speed: 1} }).addTo(routeLineLayer);
            }
        }

        // --- L√≥gica de Paradas ---

        async function drawStops(lineId, routeNodes) {
            stopMarkersLayer.clearLayers();
            stopDataCache[lineId] = {};
            
            try {
                const nodesData = await fetchBurgosAPI('resourceNodes', lineId);
                const nodesMap = new Map(nodesData.map(node => [node.num.toString(), node])); 

                routeNodes.forEach(routeNode => {
                    const nodeNum = routeNode.num.toString();
                    const fullNodeData = nodesMap.get(nodeNum);
                    
                    if (!fullNodeData) return;

                    if (!stopDataCache[lineId][nodeNum]) {
                         stopDataCache[lineId][nodeNum] = fullNodeData;
                    }
                    
                    // **FIX:** Usar el DivIcon m√°s limpio
                    const marker = L.marker([fullNodeData.lat, fullNodeData.lng], {
                        icon: L.divIcon({
                            className: 'stop-icon', // Usar el estilo definido en <style>
                            html: '',
                            iconSize: [16, 16], // Tama√±o expl√≠cito
                            iconAnchor: [8, 8],  // Anclaje central
                            popupAnchor: [0, -7]
                        })
                    }).addTo(stopMarkersLayer);
                    
                    marker.bindPopup(`<div class="text-gray-600 font-semibold py-2 text-center">${fullNodeData.name} (${nodeNum})<br>Cargando horarios...</div>`);
                    
                    marker.on('popupopen', (e) => {
                        loadEstimationsForStop(lineId, nodeNum, e.target);
                    });
                });

            } catch (error) {
                showStatus(`Error al cargar datos de paradas (resourceNodes).`, true);
            }
        }

        async function loadEstimationsForStop(lineId, stopId, marker) {
            let stopName = stopDataCache[lineId] && stopDataCache[lineId][stopId] ? stopDataCache[lineId][stopId].name : `Parada ${stopId}`;

            marker.setPopupContent(`
                <div class="font-bold text-lg text-blue-600 text-center mb-2">${stopName}</div>
                <div class="text-gray-600 font-semibold text-center py-2">Cargando horarios de llegada...</div>
            `);

            try {
                // FIX 403: Usar una consulta global ('')
                const estimationsData = await fetchBurgosAPI('resourceEstimations', '', { 
                    'nodoIds': stopId,
                });

                let popupContent = `<div class="font-bold text-lg text-blue-600 text-center mb-2">${stopName}</div>`;
                
                let foundEstimations = false;
                const allEstimates = [];
                
                if (estimationsData && Array.isArray(estimationsData) && estimationsData.length > 0) {
                    const stopData = estimationsData.find(item => item.nodoId === stopId);
                    
                    if (stopData && stopData.routeEstimationByNode) {
                        stopData.routeEstimationByNode.forEach(routeEst => {
                            if (routeEst.publicEstimationVHExts) {
                                routeEst.publicEstimationVHExts.forEach(est => {
                                    if (est.destination) {
                                        allEstimates.push({
                                            line: routeEst.line,
                                            destination: routeEst.destination,
                                            seconds: est.seconds
                                        });
                                    }
                                });
                            }
                        });
                    }
                }
                
                // Ordenar por tiempo de llegada
                allEstimates.sort((a, b) => a.seconds - b.seconds);

                if (allEstimates.length > 0) {
                    popupContent += `<table class="min-w-full text-sm"><thead><tr><th class="text-left font-semibold text-gray-700">L√≠nea/Destino</th><th class="text-right font-semibold text-gray-700">Llegada</th></tr></thead><tbody>`;

                    allEstimates.forEach(est => {
                        popupContent += `<tr>
                                            <td class="pr-4 border-b border-gray-100 py-1">L${est.line} - ${est.destination}</td>
                                            <td class="text-right font-bold text-blue-700 border-b border-gray-100">${secondsToTime(est.seconds)}</td>
                                         </tr>`;
                        foundEstimations = true;
                    });
                    popupContent += `</tbody></table>`;
                }
                
                if (!foundEstimations) {
                    popupContent += `<p class="mt-2 text-sm text-gray-500 text-center">Sin estimaciones en este momento para esta parada.</p>`;
                }

                marker.setPopupContent(popupContent);

            } catch (error) {
                marker.setPopupContent(`<div class="text-red-600 text-center">Error al cargar horarios. Por favor, intente de nuevo.</div>`);
                console.error("Error al cargar estimaciones:", error);
            }
        }
        
        // --- L√≥gica de Buses ---

        function getRouteDestination(lineId, routeId) {
            const lineVariants = allRoutes[lineId];
            if (!lineVariants) return "Cargando...";
            // Buscamos la variante cuya ruta interna (routeId) coincida con la ruta del bus
            const variant = lineVariants.find(v => v.routeNode && v.routeNode.length > 0 && v.routeNode[0].routeId === routeId);
            return variant ? variant.label : "Desconocido";
        }

        async function loadNextStopEstimation(busId, lineId, marker) {
            // Buscamos la informaci√≥n del bus en la cach√© global, que siempre se est√° actualizando
            const busData = ALL_ACTIVE_BUSES.get(busId.toString()); 
            const fleetData = BUS_FLEET_DATA[busId];
            
            if (!busData) {
                marker.setPopupContent(`<div class="text-red-600">Bus ID ${busId} no encontrado o ha desaparecido.</div>`);
                return;
            }

            try {
                const destination = getRouteDestination(lineId, busData.ruta);

                let fleetInfo = `
                    <div class="text-sm mt-2 p-2 bg-gray-50 rounded-lg border border-red-300">
                        <p class="font-semibold text-gray-700">Flota: <span class="text-red-600">Informaci√≥n desconocida (ID no mapeado)</span></p>
                    </div>
                `;

                if (fleetData) {
                    fleetInfo = `
                        <div class="text-sm mt-2 p-2 bg-gray-50 rounded-lg border border-gray-200">
                            <p><span class="font-semibold text-gray-700">Calca:</span> ${fleetData.calca}</p>
                            <p><span class="font-semibold text-gray-700">Modelo:</span> ${fleetData.modelo}</p>
                            <p><span class="font-semibold text-gray-700">Matr√≠cula:</span> ${fleetData.matricula}</p>
                        </div>
                    `;
                }
                
                const popupContent = `
                    <div class="font-bold text-lg text-blue-600 border-b pb-2">BUS ID: ${busId} (L√≠nea ${lineId})</div>
                    <p class="text-sm mt-2">Destino: <span class="font-semibold">${destination}</span></p>
                    ${fleetInfo}
                    <p class="text-xs text-gray-500 mt-2 text-center">Datos en tiempo real (Actualizaci√≥n cada ${POLLING_LINE_MS / 1000}s)</p>
                `;
                
                marker.setPopupContent(popupContent);
                
            } catch (error) {
                marker.setPopupContent(`<div class="text-red-600">Error al cargar info del bus.</div>`);
                console.error("Error al cargar estimaci√≥n del veh√≠culo:", error);
            }
        }
        
        // **FIX DEL FALLO 3:** Ahora acepta los datos de veh√≠culos espec√≠ficos de la l√≠nea
        function updateBusMarkers(lineId, vehiclesData) {
            // vehiclesData contiene solo los buses de la l√≠nea seleccionada
            const vehicles = vehiclesData || [];
            const activeIds = new Set();
            
            // 1. A√±adir/Mover buses activos
            vehicles.forEach(bus => {
                const busId = bus.id.toString();
                const marker = busMarkers.get(busId);
                activeIds.add(busId);

                if (isNaN(bus.lat) || isNaN(bus.lng)) {
                     console.warn(`Bus ID ${busId} tiene coordenadas inv√°lidas. Omitiendo actualizaci√≥n.`);
                     return; 
                }

                if (marker) {
                    // Mover el marcador existente
                    marker.setLatLng([bus.lat, bus.lng]);
                } else {
                    // Crear un nuevo marcador si aparece un bus nuevo
                    const icon = L.divIcon({
                        className: 'bus-icon',
                        html: `<span class="leading-none text-sm">${busId}</span>`,
                        iconSize: [36, 36],
                        iconAnchor: [18, 18]
                    });

                    const newMarker = L.marker([bus.lat, bus.lng], { icon: icon, title: `Bus ID: ${busId}` }).addTo(busMarkersLayer);
                    newMarker.bindPopup(`<div class="text-gray-600 font-semibold py-2 text-center">Cargando datos del Bus ID ${busId}...</div>`);
                    
                    newMarker.on('popupopen', (e) => {
                        loadNextStopEstimation(bus.id, lineId, e.target);
                    });
                    
                    busMarkers.set(busId, newMarker);
                }
            });

            // 2. Limpiar buses desaparecidos
            busMarkers.forEach((marker, id) => {
                if (!activeIds.has(id.toString())) {
                    busMarkersLayer.removeLayer(marker);
                    busMarkers.delete(id);
                }
            });
            
            // 3. Actualizar la cach√© global de los buses de esta l√≠nea (para el buscador)
            vehicles.forEach(bus => {
                 ALL_ACTIVE_BUSES.set(bus.id.toString(), { ...bus, lineId });
            });
        }
        
        document.addEventListener('DOMContentLoaded', initMap);
    </script>
</body>
</html>
